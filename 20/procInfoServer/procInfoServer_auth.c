/*
 *
 * Copyright 2012, 2013. Antonino N. Mione
 *
 */
/*
 * procInfoServer_auth.c
 */

#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
// #include <malloc.h>

#include "procInfoServer.h"
#include "procInfoServer_util.h"

/*
 * This is the name of the file holding authentication records.
 * These records are in the form:
 *
 * user:<shaHashOf[user:passwordstring]>
 *
 */
char *auth_filename = ".authFile";

/*
 * This is the number of authentication records actually read
 * from the auth file.
 */
static int numAuthRecords = 0;

/*
 * Global flags to track if the user has authenticated, whether the connection
 * should be dropped, and whether to exit the program.
 */
extern int authenticated;
extern int dropConnection;
extern int exit_program;

/*
 * Authentication records read from the auth file.
 */
static struct auth_record auth_records[max_auth_records];

/*
 * function: read_auth_record - This function reads data from the
 *              .authFile file. It parses lines splitting them into 
 *              username and a sha hash.
 *
 * parameters: None.
 *             
 *
 * return: None.
 *
 */
void read_auth_records(void)
{
   FILE *aFile;                     /* File handle for the auth records file */
   char rbuffer[max_file_line_len]; /* Working buffer for auth records */
   int length;                      /* This is the length returned by the 
                                     * read operation */
   int res = false;                 /* This is the result to be returned */

   /*
    * Open the auth file.
    */
   aFile = fopen(auth_filename, "r");
   if (aFile)
   {
      /* 
       * The auth file open succeeded. Start reading lines.
       */
      while ((res = readline(aFile, rbuffer, &length)) > 0)
      {
         /*
          * This loop parses and stores authentication records into
          * an array for auth checking later.
          */
         char cookieString[max_line_len]; /* This holds the current cookie */
         unsigned int cpyCount = 0;       /* Character count to copy */
         char *spPos;                     /* This is the separator position */
         char uPart[max_line_len];        /* User part of the record */
         char cPart[max_line_len];        /* The cookie part of the rec */
   
         /*
          * For each record read, split the line on the ':'.
          */
         spPos = index(rbuffer, ':');
         cpyCount = ((unsigned int)(spPos - rbuffer) < max_line_len) ?
             (spPos - rbuffer) :
             max_line_len;

         /*
          * Separate and save the username part of the string and the cookie
          * string.
          */
         strncpy(auth_records[numAuthRecords].user_name, rbuffer, cpyCount);
         strncpy(auth_records[numAuthRecords].cookie_string,
                 spPos + 1,
                 strlen(rbuffer) - cpyCount - 1);

         /*
          * Make sure there is a null terminator byte on the end of the
          * cookie string.
          */
         auth_records[numAuthRecords].cookie_string[strlen(rbuffer) - cpyCount 
- 2] = 0;
         numAuthRecords++;        /* Advance to next index in array. */
      }
      /*
       * Close the .authFile. It is not absoultely necessary but it
       * is 'good practice'.
       */
      fclose(aFile);
   }
}

/*
 * function: get_cookie - This function returns the 'cookie' which is 
 *              the hash value generated by hashing "username:passwordstring".
 *
 * parameters: user (char *) - This is a pointer to the user name string
 *                to be matched.
 *
 * return: char * - This is the matching cookie if a record is found. If
 *            not, a null pointer is returned.
 *
 */
char * get_cookie(char *user)
{
   int idx = 0;

   /*
    * For each record in the array (until the user is found among the auth
    * records), compare the user provided in the call with the user
    * name from the auth record. If it matches, return a pointer to the
    * associated cookie string.
    */
   while (idx < numAuthRecords)
   {
      if (strcmp(user, auth_records[idx].user_name) == 0)
      {
        /* The user matched. Return the address of this record. */
        return (auth_records[idx].cookie_string);
      }
      idx++;
   }
   return 0;
}

/*
 * function: check_auth - This function verifies the authentication information
 *              sent by the user. It expects a username and cookie separated
 *              by a colon (:). It splits the string, looks up the cookie
 *              in the array loaded from .authFile, and compares the cookie
 *              sent by the client with the cookie returned.
 *
 * parameters: cookie (char *) - This is the string provided with the
 *                authentication attempt.
 *
 * return: int
 *
 */
int check_auth (char *cookie)
{
   char cookieString[max_line_len];  /* Cookie string buffer */
   unsigned int cpyCount = 0;        /* Count of characters to copy */
   char *spPos;                      /* Position index */
   char uPart[max_line_len];         /* */
   char cPart[max_line_len];         /* */
   char *cRet;                       /* */
   
   /*
    * Look for a colon in the argument. The text before the colon is the
    * username for which to search. The remaining text is the cookie to
    * compare.
    */ 
   spPos = index(cookie, ':');
   cpyCount = ((unsigned int)(spPos - cookie) < max_line_len) ?
      (spPos - cookie) :
      max_line_len;
   /*
    * Copy the username in uPart and the cookie string into cPart.
    * Add null terminators to assure they have a finite length.
    */
   strncpy(uPart, cookie, cpyCount);
   strncpy(cPart, spPos + 1, strlen(cookie) - cpyCount - 1);
   uPart[cpyCount] = 0;
   cPart[strlen(cookie) - cpyCount - 1] = 0;
   
   /*
    * This call retrieves the authentication for the user from the
    * array holding the authentication records.
    */
   cRet = get_cookie(uPart);
   if (cRet)
   {
      /*
       * A non-zero pointer was returned, so the user was found. The
       * pointer returned is to the cookie string. This is compared
       * with the cookie from the string passed in. If they match
       * and strcmp() returns 0, then the authentication succeeded.
       */
      if (strcmp(cRet,cPart) == 0)
      {
         /*
          * The cookie string matched for the user. Authentication
          * was successful.
          */
         return 1;
      }
      else
      {
         /*
          * The username had matched, but the cookie strings do not match
          * meaning the password is incorrect. Return failure.
          */
         return 0;
      }
   }
   else
   {
      /*
       * No cookie was found for the user. User does not exist.
       * Return failure.
       */
      return 0;
   }
}
